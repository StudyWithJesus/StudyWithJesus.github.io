<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noindex, nofollow">
  <title>Fingerprint Admin Dashboard</title>
  <link rel="stylesheet" href="../../style.css">
  <link rel="stylesheet" href="../../assets/css/admin-styles.css">
  <link rel="stylesheet" href="../../assets/css/admin-responsive.css">
  <!-- Firebase Configuration (must load before github-auth.js) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script src="../../config/firebase.config.js"></script>
  <!-- GitHub OAuth Configuration -->
  <script src="../../config/github-oauth.config.js"></script>
  <script src="../../assets/js/github-auth.js"></script>
  <!-- Fingerprint Logger - captures visitor's own fingerprint and IP -->
  <script src="../../assets/fingerprint-logger.js"></script>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="back-link">
        <a href="index.html">‚Üê Back to Admin Hub</a>
        <a href="../../index.html">‚Üê Back to Main Site</a>
      </div>
      <h1>üîí Fingerprint Admin Dashboard</h1>
      <p>Manage and control access via fingerprint whitelist</p>
      <button class="logout-btn" onclick="logout()" style="display: none;" id="logout-btn">Logout</button>
    </div>

    <!-- Authentication Section -->
    <div class="auth-section" id="auth-section">
      <!-- Will be populated by GitHub Auth -->
    </div>
    
    <!-- Main Dashboard Content -->
    <div class="main-content" id="main-content" style="display: none;">
      <!-- Stats Section -->
      <div class="stats">
        <div class="stat-card">
          <h3 id="total-fingerprints">0</h3>
          <p>Total Fingerprints</p>
        </div>
        <div class="stat-card">
          <h3 id="blocked-fingerprints">0</h3>
          <p>Blocked</p>
        </div>
        <div class="stat-card">
          <h3 id="allowed-fingerprints">0</h3>
          <p>Allowed</p>
        </div>
      </div>

      <!-- Alert Box -->
      <div class="alert info">
        <strong>‚ÑπÔ∏è How it works:</strong> Toggle the switch next to a fingerprint to block or allow access. 
        Blocked fingerprints are added to the blacklist. IP addresses are tracked for information only and are NOT used for blocking. Changes are saved automatically.
      </div>

      <!-- Controls -->
      <div class="controls">
        <input 
          type="text" 
          id="search-input" 
          placeholder="Search by name, fingerprint hash, or IP address..."
          oninput="filterFingerprints()"
        >
        <button onclick="refreshData()">üîÑ Refresh</button>
        <button onclick="exportWhitelist()">üì• Export Blacklist</button>
        <button onclick="clearAllBlocks()" class="danger">üóëÔ∏è Clear All Blocks</button>
      </div>

      <!-- Fingerprint List -->
      <div class="fingerprint-list" id="fingerprint-list">
        <!-- Will be populated dynamically -->
      </div>
    </div>
  </div>

  <script>
    // Configuration
    const STORAGE_KEY_BLOCKED = 'fingerprint_blocked_list';
    const STORAGE_KEY_FINGERPRINTS = 'fingerprint_logs';
    
    // Constants for IP placeholders
    const IP_NOT_AVAILABLE = 'N/A';
    const IP_LOCAL = 'N/A (local)';
    
    // State
    let fingerprintData = [];
    let blockedFingerprints = new Set();
    let currentUser = null;

    /**
     * Show dashboard
     */
    async function showDashboard(user) {
      currentUser = user;
      document.getElementById('auth-section').style.display = 'none';
      document.getElementById('main-content').style.display = 'block';
      
      // Show user info in header
      showUserInfo(user);
      
      // Log admin access to Firestore
      await logAdminAccess(user, 'fingerprint_dashboard_view');
      
      loadData();
    }
    
    /**
     * Show user info in header
     */
    function showUserInfo(user) {
      const header = document.querySelector('.header');
      const logoutBtn = document.getElementById('logout-btn');
      if (logoutBtn) logoutBtn.remove();
      
      const userInfo = document.createElement('button');
      userInfo.id = 'logout-btn';
      userInfo.className = 'logout-btn';
      userInfo.onclick = () => GitHubAuth.logout();
      userInfo.style.display = 'flex';
      userInfo.style.alignItems = 'center';
      userInfo.style.gap = '8px';
      userInfo.innerHTML = `
        <img src="${user.avatar}" alt="${user.username}" style="width: 24px; height: 24px; border-radius: 50%;">
        <span>${user.username}</span>
      `;
      header.appendChild(userInfo);
    }

    /**
     * Load data from Firestore and localStorage
     */
    async function loadData() {
      // Load blocked fingerprints list
      const blockedList = localStorage.getItem(STORAGE_KEY_BLOCKED);
      blockedFingerprints = new Set(blockedList ? JSON.parse(blockedList) : []);

      // Load fingerprint logs from Firestore
      fingerprintData = await loadFingerprintLogs();

      updateStats();
      renderFingerprints();
    }

    /**
     * Load fingerprint logs from Firestore
     * Falls back to localStorage if Firestore is unavailable
     */
    async function loadFingerprintLogs() {
      try {
        // Initialize Firebase
        if (!firebase.apps || firebase.apps.length === 0) {
          if (!window.FIREBASE_CONFIG) {
            throw new Error('Firebase config not found');
          }
          firebase.initializeApp(window.FIREBASE_CONFIG);
        }
        
        // Wait for auth to be ready
        const auth = firebase.auth();
        if (!auth.currentUser) {
          // Wait up to 3 seconds for auth to initialize
          await new Promise((resolve, reject) => {
            const timeout = setTimeout(() => reject(new Error('Auth timeout')), 3000);
            const unsubscribe = auth.onAuthStateChanged(user => {
              clearTimeout(timeout);
              unsubscribe();
              if (user) {
                resolve(user);
              } else {
                reject(new Error('Not authenticated'));
              }
            });
          });
        }
        
        const db = firebase.firestore();
        
        // Log access attempt
        if (currentUser) {
          await logAdminAccess(currentUser, 'fingerprint_data_read', { count: 'loading' });
        }
        
        // Fetch all fingerprints from Firestore
        const snapshot = await db.collection('fingerprints').get();
        
        if (snapshot.empty) {
          console.log('No fingerprints in Firestore yet');
          return [];
        }
        
        const data = [];
        snapshot.forEach(doc => {
          const fpData = doc.data();
          data.push({
            id: fpData.firstSeen?.toMillis() || Date.now(),
            name: fpData.name || 'Guest',
            fingerprint: fpData.fingerprint || doc.id,
            ip: fpData.ip || 'N/A',
            ipv4: fpData.ipv4 || null,
            ipv6: fpData.ipv6 || null,
            timestamp: fpData.firstSeen?.toDate().toISOString() || new Date().toISOString(),
            lastSeen: fpData.lastSeen?.toDate().toISOString() || new Date().toISOString(),
            userAgent: fpData.userAgent || '',
            visitCount: fpData.visitCount || 1
          });
        });
        
        // Sort by last seen (most recent first)
        data.sort((a, b) => new Date(b.lastSeen) - new Date(a.lastSeen));
        
        // Log successful data access with count
        if (currentUser) {
          await logAdminAccess(currentUser, 'fingerprint_data_read', { 
            count: data.length,
            action: 'success'
          });
        }
        
        console.log(`Loaded ${data.length} fingerprints from Firestore`);
        return data;
        
      } catch (error) {
        console.error('Failed to load from Firestore:', error);
        
        // Log failed access attempt
        if (currentUser) {
          await logAdminAccess(currentUser, 'fingerprint_data_read', { 
            action: 'failed',
            error: error.message
          });
        }
        
        // Fallback to localStorage
        const logs = localStorage.getItem(STORAGE_KEY_FINGERPRINTS);
        let data = logs ? JSON.parse(logs) : [];
        
        console.log(`Fallback: Loaded ${data.length} fingerprints from localStorage`);
        return data;
      }
    }
    
    /**
     * Log admin access to Firestore for audit trail
     * @param {Object} user - Current user object
     * @param {string} action - Action being performed
     * @param {Object} metadata - Additional metadata
     */
    async function logAdminAccess(user, action, metadata = {}) {
      try {
        if (!firebase.apps || firebase.apps.length === 0) {
          if (!window.FIREBASE_CONFIG) return;
          firebase.initializeApp(window.FIREBASE_CONFIG);
        }
        
        const db = firebase.firestore();
        
        await db.collection('admin_logs').add({
          userId: user.uid || 'unknown',
          username: user.username || user.displayName || 'unknown',
          email: user.email || null,
          action: action,
          page: 'fingerprint_admin',
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          metadata: metadata,
          userAgent: navigator.userAgent,
          url: window.location.href
        });
        
        console.log(`Audit log: ${action} by ${user.username}`);
      } catch (error) {
        // Silent failure - don't disrupt admin functionality
        console.warn('Failed to log admin access:', error);
      }
    }

    /**
     * Generate current browser fingerprint (sync version for demo)
     */
    function generateCurrentFingerprint() {
      const data = [
        navigator.userAgent || '',
        navigator.language || '',
        navigator.hardwareConcurrency || '',
        navigator.deviceMemory || '',
        navigator.platform || '',
        screen.width + 'x' + screen.height,
        screen.colorDepth || '',
        new Date().getTimezoneOffset(),
        !!window.sessionStorage,
        !!window.localStorage,
        !!window.indexedDB,
        navigator.cookieEnabled
      ].join('|');
      
      // Simple hash for demo (in production, use crypto.subtle.digest)
      let hash = 0;
      for (let i = 0; i < data.length; i++) {
        const char = data.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return Math.abs(hash).toString(16).padStart(64, '0').substring(0, 64);
    }

    /**
     * Update statistics
     */
    function updateStats() {
      const total = fingerprintData.length;
      const blocked = fingerprintData.filter(fp => blockedFingerprints.has(fp.fingerprint)).length;
      const allowed = total - blocked;

      document.getElementById('total-fingerprints').textContent = total;
      document.getElementById('blocked-fingerprints').textContent = blocked;
      document.getElementById('allowed-fingerprints').textContent = allowed;
    }

    /**
     * Render fingerprints
     */
    function renderFingerprints() {
      const listEl = document.getElementById('fingerprint-list');
      const searchTerm = document.getElementById('search-input').value.toLowerCase();

      const filtered = fingerprintData.filter(fp => 
        fp.name.toLowerCase().includes(searchTerm) || 
        fp.fingerprint.toLowerCase().includes(searchTerm) ||
        (fp.ip && fp.ip.toLowerCase().includes(searchTerm))
      );

      if (filtered.length === 0) {
        listEl.innerHTML = `
          <div class="empty-state">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="12" y1="8" x2="12" y2="12"></line>
              <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
            <h3>No fingerprints found</h3>
            <p>Fingerprints will appear here as users visit the site</p>
          </div>
        `;
        return;
      }

      listEl.innerHTML = filtered.map(fp => {
        const isBlocked = blockedFingerprints.has(fp.fingerprint);
        const itemClass = isBlocked ? 'fingerprint-item blocked' : 'fingerprint-item';
        const toggleClass = isBlocked ? 'toggle-switch active' : 'toggle-switch';
        const labelClass = isBlocked ? 'toggle-label blocked' : 'toggle-label';
        const labelText = isBlocked ? 'BLOCKED' : 'Allowed';
        const ipAddress = fp.ip || IP_NOT_AVAILABLE;
        // Escape IP for safe use in onclick attribute
        const safeIp = escapeHtml(ipAddress).replace(/'/g, '&#39;');

        return `
          <div class="${itemClass}">
            <div 
              class="${toggleClass}" 
              onclick="toggleBlock('${fp.fingerprint}', '${safeIp}')"
              title="Click to ${isBlocked ? 'allow' : 'block'}"
            ></div>
            <div class="fingerprint-info">
              <div class="name">${escapeHtml(fp.name)}</div>
              <div class="hash">${fp.fingerprint}</div>
              <div class="meta">
                ${fp.ipv4 ? `IPv4: ${escapeHtml(fp.ipv4)}` : ''}${fp.ipv4 && fp.ipv6 ? ' ‚Ä¢ ' : ''}${fp.ipv6 ? `IPv6: ${escapeHtml(fp.ipv6)}` : ''}${!fp.ipv4 && !fp.ipv6 ? `IP: ${escapeHtml(ipAddress)}` : ''} ‚Ä¢ 
                ${fp.visitCount ? `Visits: ${fp.visitCount} ‚Ä¢ ` : ''}
                Last seen: ${new Date(fp.lastSeen).toLocaleString()} ‚Ä¢ 
                First seen: ${new Date(fp.timestamp).toLocaleString()}
              </div>
            </div>
            <div class="${labelClass}">${labelText}</div>
          </div>
        `;
      }).join('');
    }

    /**
     * Toggle block status
     */
    async function toggleBlock(fingerprint, ip) {
      if (blockedFingerprints.has(fingerprint)) {
        blockedFingerprints.delete(fingerprint);
        if (currentUser) {
          await logAdminAccess(currentUser, 'fingerprint_unblock', { fingerprint, ip });
        }
      } else {
        blockedFingerprints.add(fingerprint);
        if (currentUser) {
          await logAdminAccess(currentUser, 'fingerprint_block', { fingerprint, ip });
        }
      }

      // Save to localStorage (only fingerprints, not IPs)
      localStorage.setItem(STORAGE_KEY_BLOCKED, JSON.stringify([...blockedFingerprints]));

      // Update UI
      updateStats();
      renderFingerprints();

      // Update the whitelist file configuration
      updateWhitelistFile();
    }

    /**
     * Update whitelist file configuration
     * Shows instructions for updating the whitelist-fingerprint.js file
     */
    function updateWhitelistFile() {
      console.log('Blocked fingerprints:', [...blockedFingerprints]);
      console.log('Copy these to assets/whitelist-fingerprint.js');
      console.log('Note: IPs are tracked for information only and are NOT used for blocking');
    }

    /**
     * Filter fingerprints
     */
    function filterFingerprints() {
      renderFingerprints();
    }

    /**
     * Refresh data from Firestore
     */
    async function refreshData() {
      try {
        await loadData();
        alert('‚úÖ Data refreshed successfully from Firestore!');
      } catch (error) {
        alert('‚ö†Ô∏è Failed to refresh data: ' + error.message);
      }
    }

    /**
     * Export blocklist configuration
     */
    function exportWhitelist() {
      const blocked = fingerprintData
        .filter(fp => blockedFingerprints.has(fp.fingerprint))
        .map(fp => {
          const ipInfo = fp.ip && fp.ip !== IP_NOT_AVAILABLE && fp.ip !== IP_LOCAL ? ` - IP: ${fp.ip} (info only)` : '';
          return `  '${fp.fingerprint}', // ${fp.name}${ipInfo}`;
        });

      const config = `// Blacklist Configuration (Manual Override)
// Generated: ${new Date().toISOString()}
// Copy this array to assets/whitelist-fingerprint.js (optional)

const manuallyBlockedFingerprints = [
${blocked.join('\n')}
];

// Note: IP addresses are tracked for information only and are NOT used for blocking.
// Only fingerprints (device/display name) are used to block access.
// Blocked fingerprints are automatically synced from localStorage.
// This manual list is only needed if you want permanent blocks across browsers.
// The admin dashboard automatically uses localStorage key 'fingerprint_blocked_list'.`;

      // Copy to clipboard
      navigator.clipboard.writeText(config).then(() => {
        alert('‚úÖ Blacklist configuration copied to clipboard!\n\n(Optional) Paste this into assets/whitelist-fingerprint.js for manual overrides.\n\nNote: Only fingerprints are used for blocking. IPs are tracked for information only.');
      }).catch(() => {
        // Fallback: show in alert
        prompt('Copy this blacklist configuration (optional):', config);
      });
    }

    /**
     * Clear all blocks
     */
    async function clearAllBlocks() {
      if (confirm('Are you sure you want to allow all fingerprints?')) {
        const count = blockedFingerprints.size;
        blockedFingerprints.clear();
        localStorage.setItem(STORAGE_KEY_BLOCKED, JSON.stringify([]));
        
        if (currentUser) {
          await logAdminAccess(currentUser, 'fingerprint_clear_all_blocks', { count });
        }
        
        updateStats();
        renderFingerprints();
        alert('‚úÖ All blocks cleared!');
      }
    }

    /**
     * Escape HTML
     */
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    /**
     * Initialize
     */
    async function init() {
      // Check if GitHub Auth is available
      if (!window.GitHubAuth) {
        console.error('GitHub Auth module not loaded');
        document.getElementById('auth-section').innerHTML = `
          <div style="padding: 40px; text-align: center;">
            <h2>Configuration Error</h2>
            <p style="color: #666; margin: 20px 0;">Firebase Authentication is not properly configured.</p>
            <p style="color: #666;">Please configure Firebase as described in FIREBASE_SETUP_GUIDE.md.</p>
          </div>
        `;
        return;
      }
      
      // Check GitHub authentication
      try {
        const user = await GitHubAuth.requireAuth();
        // User is authenticated - show dashboard
        showDashboard(user);
      } catch (err) {
        // Not authenticated - show login UI
        document.getElementById('main-content').style.display = 'none';
        GitHubAuth.showAuthUI('auth-section');
      }
    }

    // Listen for successful login events
    window.addEventListener('githubauth:login', function(event) {
      console.log('Login event received, refreshing UI...');
      // Re-initialize the page to show authenticated content
      init();
    });

    // Initialize on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
